"""Sandbox manager — slot dir, env/override generation, Docker lifecycle."""

from __future__ import annotations

import logging
import shutil
import subprocess
import time
import urllib.request
from datetime import datetime, timezone
from pathlib import Path

from devops_ai.config import InfraConfig
from devops_ai.registry import SlotInfo

logger = logging.getLogger(__name__)

DEFAULT_SLOTS_BASE = Path.home() / ".devops-ai" / "slots"


def create_slot_dir(
    project: str, slot_id: int, *, base: Path | None = None
) -> Path:
    """Create slot directory at ~/.devops-ai/slots/<project>-<slot_id>/."""
    base = base or DEFAULT_SLOTS_BASE
    slot_dir = base / f"{project}-{slot_id}"
    slot_dir.mkdir(parents=True, exist_ok=True)
    return slot_dir


def remove_slot_dir(slot_dir: Path) -> None:
    """Remove a slot directory and all contents."""
    shutil.rmtree(slot_dir, ignore_errors=True)


def copy_compose_to_slot(
    compose_path: Path, slot_dir: Path
) -> Path:
    """Copy worktree's compose file to slot dir for teardown safety."""
    dest = slot_dir / compose_path.name
    shutil.copy2(compose_path, dest)
    return dest


def generate_env_file(
    config: InfraConfig,
    slot: SlotInfo,
    slot_dir: Path,
) -> Path:
    """Write .env.sandbox with COMPOSE_PROJECT_NAME and offset ports."""
    lines = [
        f"COMPOSE_PROJECT_NAME={config.project_name}-slot-{slot.slot_id}",
    ]
    for env_var, port in sorted(slot.ports.items()):
        lines.append(f"{env_var}={port}")

    env_path = slot_dir / ".env.sandbox"
    env_path.write_text("\n".join(lines) + "\n")
    return env_path


def _observability_network_exists() -> bool:
    """Check if devops-ai-observability Docker network exists."""
    try:
        result = subprocess.run(
            ["docker", "network", "inspect", "devops-ai-observability"],
            capture_output=True,
            text=True,
        )
        return result.returncode == 0
    except FileNotFoundError:
        return False


def _build_volume_line(
    mount, base_path: Path  # noqa: ANN001 — MountEntry
) -> str:
    """Build a volume mount line with absolute path."""
    abs_host = f"{base_path}/{mount.host}"
    line = f"      - {abs_host}:{mount.container}"
    if mount.readonly:
        line += ":ro"
    return line


def generate_override(
    config: InfraConfig,
    slot: SlotInfo,
    worktree_path: Path,
    main_repo_path: Path,
    slot_dir: Path,
) -> Path:
    """Generate docker-compose.override.yml with volume mounts.

    Observability network and OTEL env vars included only if the
    devops-ai-observability Docker network exists.
    """
    now = datetime.now(timezone.utc).isoformat(timespec="seconds")
    has_observability = _observability_network_exists()

    lines: list[str] = [
        "# Generated by kinfra impl — do not edit manually",
        f"# Worktree: {worktree_path}",
        f"# Slot: {config.project_name}-{slot.slot_id}",
        f"# Generated at: {now}",
        "",
    ]

    # Networks section (only if observability exists)
    if has_observability:
        lines += [
            "networks:",
            "  devops-ai-observability:",
            "    external: true",
            "",
        ]

    # Collect all target services
    all_targets: set[str] = set()
    all_targets.update(config.code_mount_targets)
    all_targets.update(config.shared_mount_targets)

    if all_targets:
        lines.append("services:")
        for target in sorted(all_targets):
            lines.append(f"  {target}:")

            # Observability network + OTEL env
            if has_observability:
                lines += [
                    "    networks:",
                    "      - default",
                    "      - devops-ai-observability",
                    "    environment:",
                    "      - OTEL_EXPORTER_OTLP_ENDPOINT="
                    "http://devops-ai-jaeger:4317",
                    "      - OTEL_RESOURCE_ATTRIBUTES="
                    f"service.namespace="
                    f"{config.project_name}-slot-{slot.slot_id}",
                ]

            # Volume mounts
            volumes: list[str] = []
            if target in config.code_mount_targets:
                for mount in config.code_mounts:
                    volumes.append(
                        _build_volume_line(mount, worktree_path)
                    )
            if target in config.shared_mount_targets:
                for mount in config.shared_mounts:
                    volumes.append(
                        _build_volume_line(mount, main_repo_path)
                    )

            if volumes:
                lines.append("    volumes:")
                lines.extend(volumes)

    override_path = slot_dir / "docker-compose.override.yml"
    override_path.write_text("\n".join(lines) + "\n")
    return override_path


# ---------------------------------------------------------------------------
# Docker lifecycle
# ---------------------------------------------------------------------------


def _compose_cmd(
    compose_file: str | Path,
    override_file: str | Path,
    env_file: str | Path,
    action: list[str],
) -> list[str]:
    """Build a docker compose command with absolute paths."""
    return [
        "docker",
        "compose",
        "-f",
        str(compose_file),
        "-f",
        str(override_file),
        "--env-file",
        str(env_file),
        *action,
    ]


def start_sandbox(
    config: InfraConfig,
    slot: SlotInfo,
    worktree_path: Path,
) -> None:
    """Start sandbox containers using worktree's compose file.

    On failure, runs compose down to clean partial containers, then raises.
    """
    slot_dir = Path(slot.slot_dir)
    compose_file = worktree_path / config.compose_file
    override_file = slot_dir / "docker-compose.override.yml"
    env_file = slot_dir / ".env.sandbox"

    cmd = _compose_cmd(compose_file, override_file, env_file, ["up", "-d"])
    logger.info("Starting sandbox: %s", " ".join(cmd))

    try:
        result = subprocess.run(cmd, capture_output=True, text=True)
    except FileNotFoundError:
        raise RuntimeError(
            "Docker is not installed or not on PATH"
        ) from None

    if result.returncode != 0:
        logger.error("Sandbox start failed: %s", result.stderr)
        # Cleanup partial containers
        down_cmd = _compose_cmd(
            compose_file, override_file, env_file, ["down"]
        )
        subprocess.run(down_cmd, capture_output=True, text=True)
        raise RuntimeError(
            f"Sandbox failed to start: {result.stderr.strip()}"
        )


def stop_sandbox(slot: SlotInfo) -> None:
    """Stop sandbox containers using slot dir's compose copy.

    Uses the compose copy (not worktree) because the worktree might
    already be removed. Errors are ignored (best-effort cleanup).
    """
    slot_dir = Path(slot.slot_dir)
    compose_file = slot.compose_file_copy
    override_file = slot_dir / "docker-compose.override.yml"
    env_file = slot_dir / ".env.sandbox"

    cmd = _compose_cmd(compose_file, override_file, env_file, ["down"])
    logger.info("Stopping sandbox: %s", " ".join(cmd))

    try:
        subprocess.run(cmd, capture_output=True, text=True)
    except FileNotFoundError:
        logger.warning("Docker not found, cannot stop sandbox")


def run_health_gate(config: InfraConfig, slot: SlotInfo) -> bool:
    """Poll health endpoint until HTTP 200 or timeout.

    Returns True on success, False on timeout. Non-fatal.
    """
    if not config.health_endpoint or not config.health_port_var:
        logger.info("No health check configured, skipping")
        return True

    port = slot.ports.get(config.health_port_var)
    if port is None:
        logger.warning(
            "Health port var %s not in slot ports", config.health_port_var
        )
        return False

    endpoint = config.health_endpoint
    if not endpoint.startswith("/"):
        endpoint = f"/{endpoint}"
    url = f"http://localhost:{port}{endpoint}"

    timeout = config.health_timeout
    deadline = time.monotonic() + timeout
    attempt = 0

    while time.monotonic() < deadline:
        attempt += 1
        try:
            with urllib.request.urlopen(url, timeout=5) as resp:
                if resp.status == 200:
                    logger.info(
                        "Health check passed (attempt %d)", attempt
                    )
                    return True
        except Exception:
            logger.info(
                "Health check attempt %d... waiting", attempt
            )
        time.sleep(2)

    logger.warning("Health check timed out after %ds", timeout)
    return False
